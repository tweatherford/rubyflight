#!/usr/bin/ruby
require 'fox16'
include Fox

class Window < FXMainWindow
  def initialize(app)
    super(app, "FS Operations", :width => 800, :height => 400)
    app.main_window = self

    # Status bar along the bottom
    @statusbar = FXStatusBar.new(self, LAYOUT_SIDE_BOTTOM | LAYOUT_FILL_X | STATUSBAR_WITH_DRAGCORNER)

    # Main contents area is split left-to-right
    splitter = FXSplitter.new(self, (LAYOUT_SIDE_TOP | LAYOUT_FILL_X | LAYOUT_FILL_Y | SPLITTER_TRACKING))

    # Shutter area on the left
    @shutter = FXShutter.new(splitter, :opts => FRAME_SUNKEN | LAYOUT_FILL_X | LAYOUT_FILL_Y,
      :padding => 0, :hSpacing => 0, :vSpacing => 0)

    shutter_item = ShutterItem.new(@shutter, "Sections", nil, LAYOUT_FILL_Y)
    ShutterButton.new(shutter_item.content, "Flight\nStatus").connect(SEL_COMMAND) { @switcher.current = 0 }
    ShutterButton.new(shutter_item.content, "Airport\nOperations").connect(SEL_COMMAND) { @switcher.current = 1 }
    #ShutterButton.new(shutter_item.content, "Aircrafts").connect(SEL_COMMAND) { @switcher.current = 2 }
    #ShutterButton.new(shutter_item.content, "Debug").connect(SEL_COMMAND) { @switcher.current = 3 }

    # Switcher on the right
    @switcher = FXSwitcher.new(splitter, FRAME_SUNKEN | LAYOUT_FILL_X | LAYOUT_FILL_Y, :padding => 0)

    #------------ Flight status -------------#
    frame = FXVerticalFrame.new(@switcher)

    matrix = FXMatrix.new(frame, 2, MATRIX_BY_COLUMNS | LAYOUT_CENTER_X)
    FXLabel.new(matrix, "Aircraft:", nil, LAYOUT_SIDE_RIGHT | LAYOUT_FILL_X)
    aircraft_label = FXLabel.new(matrix, "", nil, LAYOUT_SIDE_LEFT | LAYOUT_FILL_X)
    aircraft_label.connect(SEL_UPDATE) {
      if (RubyFlight::Simulator.instance.connected?) then aircraft_label.text = RubyFlight::Aircraft.instance.name
      else aircraft_label.text = '' end
    }

    FXLabel.new(matrix, "Status:", nil, LAYOUT_SIDE_RIGHT | LAYOUT_FILL_X)
    @status_label = FXLabel.new(matrix, "", nil, LAYOUT_SIDE_LEFT | LAYOUT_FILL_X)
    FXLabel.new(matrix, "Location:", nil, LAYOUT_SIDE_RIGHT | LAYOUT_FILL_X)
    location_label = FXLabel.new(matrix, "", nil, LAYOUT_SIDE_LEFT | LAYOUT_FILL_X)
    location_label.connect(SEL_UPDATE) {
      if (RubyFlight::Simulator.instance.connected?)
        location_label.text = RubyFlight::Aircraft.instance.nearest_airport.to_s
      else location_label.text = '' end
    }

    FXLabel.new(matrix, "Condition:", nil, LAYOUT_SIDE_RIGHT | LAYOUT_FILL_X)
    @condition_label = FXLabel.new(matrix, "?", nil, LAYOUT_SIDE_LEFT | LAYOUT_FILL_X)

    @main_button = FXButton.new(frame, 'Start Flight', nil, nil, 0, FRAME_RAISED | LAYOUT_CENTER_X, :padLeft => 10, :padRight => 10)
    font = @main_button.font.fontDesc
    font.size += 35
    @main_button.font = FXFont.new(app, font)

    #--------- Airport Operations ----------#
    frame = FXVerticalFrame.new(@switcher)

    FXLabel.new(frame, "Available at airport")
    table1 = FXTable.new(frame, nil, 0, TABLE_NO_COLSELECT | TABLE_READONLY | LAYOUT_FILL_X | LAYOUT_FILL_Y)
    table1.appendColumns(3)
    table1.setColumnText(0, "Cargo Name")
    table1.setColumnText(1, "Weight")
    table1.setColumnText(2, "Destination")
    table1.rowHeaderMode = LAYOUT_FIX_WIDTH
    table1.rowHeaderWidth = 0
    table1.connect(SEL_UPDATE) {
      # TODO: if correct status
      table1.removeRows(0, table1.numRows)
      airport = RubyFlight::Aircraft.instance.nearest_airport
      unless airport.nil?
        c = airport.available_cargo
        table1.appendRows(c.size)
        table1.numRows.times do |i|
          table1.setItemText(i, 0, c[i].name)
          table1.setItemText(i, 1, c[i].weight.to_s)
          table1.setItemText(i, 2, c[i].destination.to_s)
        end
      end
    }

    FXButton.new(frame, 'Transfer', nil, nil, 0, BUTTON_NORMAL | LAYOUT_CENTER_X)

    FXLabel.new(frame, "Available on aircraft")
    table2 = FXTable.new(frame, nil, 0, TABLE_NO_COLSELECT | TABLE_READONLY | LAYOUT_FILL_X | LAYOUT_FILL_Y)
    table2.appendColumns(3)
    table2.setColumnText(0, "Cargo Name")
    table2.setColumnText(1, "Weight")
    table2.setColumnText(2, "Destination")
    table2.rowHeaderMode = LAYOUT_FIX_WIDTH
    table2.rowHeaderWidth = 0
  end

  def create
    super
    @shutter.width *= 1.6
    show(PLACEMENT_SCREEN)
  end

  def status=(text)
    @statusbar.statusLine.normalText = text
  end
end

class ShutterItem < FXShutterItem
  def initialize(p, text, icon=nil, opts=0)
    super(p, text, icon, opts|LAYOUT_FILL_X|LAYOUT_TOP|LAYOUT_LEFT, :padding => 10, :hSpacing => 10, :vSpacing => 10)
    button.padTop = 2
    button.padBottom = 2
  end
end

class ShutterButton < FXButton
  def initialize(p, txt, ic=nil)
    super(p, txt, ic, :opts => BUTTON_TOOLBAR|TEXT_BELOW_ICON|FRAME_THICK|FRAME_RAISED|LAYOUT_FILL_X|LAYOUT_TOP|LAYOUT_LEFT)
    self.backColor = p.backColor
    self.textColor = FXRGB(255, 255, 255)
  end
end

$: << '../lib'
require 'rubyflight'
require 'classes/flight'
require 'classes/flightplan'
require 'classes/eventlogger'
require 'classes/cargo'
require 'classes/airport'
require 'rexml/document'

class Application < FXApp
  attr_accessor :main_window

  def status=(text)
    self.main_window.status = text
  end

  def error=(text)
    dialog = FXDialogBox.new(self.main_window, "Error!")
    FXLabel.new(dialog, text)
    FXButton.new(dialog, "Ok")
    dialog.execute
  end

  def create
    super
    @stop_loop = false
    self.main_window.connect(SEL_CLOSE) {
      result = FXMessageBox.question(self.main_window, MBOX_YES_NO, "Exit program", "Are you sure?")
      if (result == MBOX_CLICKED_YES) then @stop_loop = true; self.main_window = nil; 0
      else 1 end
    }
  end

  def run_loop
    RubyFlight::Airport.load_database

    self.status = 'Connecting...'
    begin
      self.runWhileEvents
      RubyFlight::Simulator.instance.connect do
        self.status = 'Connected'
        @flight = RubyFlight::Flight.new

        while !@stop_loop
          RubyFlight.read_all
          @flight.process
          self.runWhileEvents
        end
      end
    rescue RubyFlight::RubyFlightError => e
      unless (self.main_window.nil?)
        self.status = "Disconnected! (Error: #{e.message}, code: #{e.code}). Attempting reconnection..."
        #self.error = "Disconnected! (Error: #{e.message}, code: #{e.code})"
        retry
      else
        raise
      end
    end
  end
end

##---- run application ----##
app = Application.new
win = Window.new(app)
app.create
app.run_loop
